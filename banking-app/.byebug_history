c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
c
mutex.locked?
mutext.locked?
c
mutex.locked?
c
response.body.to_json
response.body.should.to_json
JSON.parse(response.body)
response.body.should
response.body.should.first
response.body
response.body.should
response.json_body
c
Transaction.where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at).count
Transaction.where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at)
created_at = self.created_at
created_at
c
created_at
c
transaction.created_at
c
created_at
created_at = created_at.in_time_zone
c
created_at
created_at = created_at.in_time_zone
created_at.in_time_zone
created_at.in_timezone
Time.now
created_at
c
mutex.locked? 
c
v
mutex.locked? 
c
Redis.new.flushall
Redis.classy.flushall
mutex.locked?
c
x
Transaction.all
Transaction.where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at).first
Transaction.where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at)
Transaction.where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at).or(Transaction.where('created_at >= ? AND created_at < ?', created_at, created_at - 1.minute))
c
params[:search_by]
c
%w[ASC DESC].exclude?(sequence.to_s)
attribute.to_s
column_names
column_names.exclude?(attribute.to_s)
c
column_names
column_name
c
"SenderType:Bank::Sender:#{bank_1.id}"
c
@bank.destroy
c
@bank.destroy
c
errors.full_messages
update(duplicate: true)
c
transaction.created_at
Transaction.last.created_at
Transaction.find(params[:id])
@transaction = Transaction.find(params[:id])
params[:id]
c
@transaction = Transaction.find(params[:id])
params[:id]
c
self
transaction_date
c
(pending.eql?(true) || changes.except('pending').empty?) && (changes.except('duplicate').empty? || !duplicate?)
c
pending?
c
(pending.eql?(true) || changes.except('pending').empty?) && (changes.except('duplicate').empty? || !duplicate?)
c
(pending.eql?(true) || changes.except('pending').empty?) && (changes.except('duplicate').empty? || !duplicate?)
duplicate?
id
!duplicate?
pending?
c
pending?
c
self
pending?
description
c
description
c
description
c
description
amount
pending?
c
@transaction.errors.full_messages
@transaction.valid?
c
@transaction.errors.full_messages
@transaction.valid?
c
@transaction
c
@transaction
@transaction.errors.full_messages
@transaction.valid?
c
@transaction
c
json_response
c
json_response["id"]
json_response
c
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date, amount_cents: amount_cents)
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date, amount_cents: amount_cents).where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at)
id
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date, amount_cents: amount_cents).where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at)
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date)
c
transaction_2
c
pending?
c
pending?
c
pending?
self.pending = false
pending?
c
pending?
self.pending = false
pending?
c
pending?
c
pending?
c
search_params
search_params&.dig('account_id').present?
c
Transaction.first
Transaction.count
Transaction.completed.ids
transaction_2.id
transaction_2.pending
transaction_1.pending
transaction_1..pending
transaction_1.id
c
transaction.deleted_at
c
transaction
c
transaction.reload.deleted_at
transaction.reload
c
duplicate
!duplicate?
changes.except('duplicate').empty?
pending?
(pending.eql?(true) || changes.except('pending').empty?)
(pending.eql?(true) || changes.except('pending').empty?) && (changes.except('duplicate').empty? || !duplicate?)
c
transaction.errors.full_messages
transaction.valid?
c
transaction.errors.full_messages
transaction.valid?
c
transaction.errors.full_messages
transaction.valid?
c
account1.balance
c
changes
c
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date,amount_cents: amount_cents).where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at).where.not(id: id).exists?
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date,amount_cents: amount_cents).where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at).count
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date,amount_cents: amount_cents).where('created_at > ? AND created_at <= ?', created_at - 1.minute, created_at)
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date,amount_cents: amount_cents)
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date,amount_cents: amount_cents
c
created_at - 1.minute
created_at - 1.minute.ago
created_at
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date, amount_cents: amount_cents).where('created_at BETWEEN ? AND ?', created_at - 1.minute.ago, created_at)
Transaction.where(sender: sender, recipient: recipient, transaction_date: transaction_date, amount_cents: amount_cents)
c
Transaction.where(sender: sender, recipient: recipient,transaction_date: transaction_date, amount_cents: amount_cents).where('created_at > ? AND created_at <= ?', created_at - 1.minute.ago, created_at).count
c
Transaction.where(sender: sender, recipient: recipient,transaction_date: transaction_date, amount_cents: amount_cents).where('created_at > ? && created_at <= ?', created_at - 1.minute.ago, created_at).count
Transaction.where(sender: sender, recipient: recipient,transaction_date: transaction_date, amount_cents: amount_cents).where('created_at > ? && created_at <= ?', created_at - 1.minute.ago, created_at)
Transaction.where(sender: sender, recipient: recipient,transaction_date: transaction_date, amount_cents: amount_cents).count
exit
c
params[:id]
c
@transaction = Transaction.find(params[:id])
Transaction.find(params[:id])
params[:id]
c
transaction_params['transaction_date'].to_date
transaction_params
c
 date_of_transaction <= Date.current && pending?
exit
date_of_transaction <= Date.current && pending?
date_of_transaction <= Date.current && !pending?
c
self
c
sent_transactions.distinct.pluck(:amount_cents)
sent_transactions.distinct.count
sent_transactions.distinct
sent_transactions.count
received_transactions.count
received_transactions
c
all_transactions.non_duplicate
c
